#!/usr/bin/env python

import json
import os
import sys
import markdown
import requests
import re
import ConfigParser

def tohtml(md):
	html = markdown.markdown(md.decode('utf-8'))
	if html == '':
		html = '<p/>'
	return html


class main(object):

	def send(self, title, html, uri=None, endpoint=None, category=None, folder=None, article=None, fn=''):
		if not uri:
			if not endpoint:
				raise ValueError, 'uri or endpoint is required'

			if category and folder and article:
				# update existing
				path = ['solution', 'categories', category,
				        'folders', folder, 'articles', article]

			elif category and folder:
				# update existing
				path = ['solution', 'categories', category,
				        'folders', folder, 'articles']

			else:
				raise ValueError, 'at least category and folder are required'

			uri = endpoint + '/'.join([str(x) for x in path])

		if not uri.endswith('.json'):
			uri += '.json'

		headers = {
			'Content-type': 'application/json',
		}

		data = {
			'solution_article': {
				'title': title,
				'description': html,
				'art_type': 1,
				'status': 2,
			},
			'tags': {},
		}

		sys.stdout.write('Sending %s (%s)...' % (title, fn))
		r = requests.put(uri,
		                 data=json.dumps(data),
		                 auth=requests.auth.HTTPBasicAuth(self.apikey, ''),
		                 headers=headers)
		sys.stdout.write('%d\n' % r.status_code)
		#if r.status_code != 200:
		#	sys.stdout.write(str(r.headers))


	def readmap(file):
		mappings = []
		fp = open(file, 'r')
		for line in fp:
			match, mapto = line.strip().split()
			mappings.append([re.compile(match, re.I), mapto])
		fp.close()
		return mappings

	def mapfilename(file):
		mapfile = os.path.join(os.path.dirname(sys.argv[0]), 'articles.map')
		mappings = readmap(mapfile)
		for r, mapto in mappings:
			m = r.search(file)
			if m:
				return m.expand(mapto)
		return None

	def __call__(self, args):
		cfg = ConfigParser.RawConfigParser()
		cfg.read(sys.argv[0] + '.ini')
		if cfg.has_section('include'):
			for option, value in cfg.items('include'):
				cfg.read(value) or cfg.read(option)

		self.apikey = cfg.get('api', 'apikey')

		mapping = []
		for option, value in cfg.items('filemap'):
			#mapping.append([re.compile(option, re.I), value])
			mapping.append([option, value])

		def mapfile(f):
			for r, value in mapping:
				#if r.search(f):
				#	return value
				if f.lower().endswith(r.lower()):
					return value
			return None

		for file in args:
			path = mapfile(file)
			if path is None:
				print 'no mapping for', file
				continue

			try:
				category, folder, article = path.split('/')
			except ValueError:
				category = '0'
				folder = '0'
				article = path

			if cfg.has_option('categories', category):
				category = cfg.get('categories', category)
			if cfg.has_option('folders', folder):
				folder = cfg.get('folders', folder)
			if cfg.has_option('articles', article):
				folder = cfg.get('articles', article)

			uri = cfg.get('api', 'uri') % locals()
			if uri is None:
				print 'no uri mapped for %s' % file
				continue
			fp = open(file, 'r')
			data = fp.read()
			fp.close()
			headlines = filter(lambda line: line.startswith('#'), data.split('\n'))
			if headlines:
				title = headlines[0].strip('#').strip()
			else:
				title = os.path.basename(file).replace('.md', '').replace('-', ' ')

			self.send(title, tohtml(data), uri, fn=file)


if __name__ == '__main__':
	sys.exit(main()(sys.argv[1:]))
